import { getConfiguration } from "@/config";
import { Client, WithDefaultsT, createClient } from "@/generated/api/client";
import { readableReport } from "@pagopa/ts-commons/lib/reporters";
import * as E from "fp-ts/lib/Either";
import { pipe } from "fp-ts/lib/function";
import * as t from "io-ts";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";

/** Custom error type for `useFetch` */
export type UseFetchError = {
  /** readable error type classification */
  kind: UseFetchErrorStatusType;
  /** http response status code, defined in case of _"httpError"_ `kind` */
  status?: number;
  /** additional error info */
  message: string;
};

/** Custom `useFetch` error classification */
export type UseFetchErrorStatusType =
  | "httpError"
  | "validationError"
  | "exceptionError";

/**
 * The status codes defined by RFC 9110
 *
 * For more details visit https://httpwg.org/specs/rfc9110.html#overview.of.status.codes
 */
type HttpResponseClassType =
  | "informational"
  | "successful"
  | "redirection"
  | "clientError"
  | "serverError"
  | "unknown";

/**
 * Given an http response status code, returns a response class as defined by **RFC 9110**
 * @param status
 * @returns
 */
const manageHttpResponseStatusCode = (
  status: number
): HttpResponseClassType => {
  if (status >= 100 && status <= 199) {
    return "informational";
  } else if (status >= 200 && status <= 299) {
    return "successful";
  } else if (status >= 300 && status <= 399) {
    return "redirection";
  } else if (status >= 400 && status <= 499) {
    return "clientError";
  } else if (status >= 500 && status <= 599) {
    return "serverError";
  } else {
    return "unknown";
  }
};

const withBearer: WithDefaultsT<"bearerAuth"> = wrappedOperation => params => {
  return wrappedOperation({
    ...params,
    bearerAuth: "VALID_TOKEN" // just a placeholder, see `clientWithBearerToken` explanations below
  });
};

/**
 * IO Services CMS generated Api Client
 *
 * Client with defaults bearerAuth, to avoid bearer token definition in each component call. */
export const clientWithBearerToken: Client<"bearerAuth"> = createClient({
  baseUrl: getConfiguration().API_BACKEND_BASE_URL,
  fetchApi: (fetch as any) as typeof fetch,
  withDefaults: withBearer
});

/** List of all client operations */
type ClientOperations = typeof clientWithBearerToken;

/** Extract operation request parameters inferred by client operationId */
type ExtractRequestParams<T extends keyof ClientOperations> = Parameters<
  ClientOperations[T]
>[0];

/**
 * Custom hook for client fetch API.
 *
 * This hook use `@pagopa/openapi-codegen-ts` autogenerated client, therefore makes available all and only APIs specified in the project root opeanapi.yaml
 * @param operationId openapi operationId
 * @param requestParams request parameters _(as specified in openapi)_
 * @param responseCodec io-ts expected response codec
 * @returns `data` fetch result of _responseCodec_ type
 * @returns `error` in case of request error, decode failure or exceptions
 * @returns `loading` as boolean value for request pending state
 */
const useFetch = <RC>() => {
  const [data, setData] = useState<RC>();
  const [error, setError] = useState<UseFetchError>();
  const [loading, setLoading] = useState(true);

  const { push } = useRouter();
  const { data: session } = useSession();

  /**
   * SetStateAction\<UseFetchError>
   * @param status
   * @param message
   * @returns
   */
  const setUseFetchError = (
    kind: UseFetchErrorStatusType,
    message: string,
    status?: number
  ) =>
    setError({
      kind,
      message,
      status
    });

  /**
   * IO Services CMS generated Api Client
   *
   * Client without defaults: we need to create it inside `useFetch()`
   * because a React Hook should not be called at the top level.
   * React Hooks must be called in a React function component or a custom React Hook function. */
  const client: Client = createClient({
    baseUrl: getConfiguration().API_BACKEND_BASE_URL,
    fetchApi: (fetch as any) as typeof fetch
  });

  const fetchData = async <T extends keyof ClientOperations>(
    operationId: T,
    requestParams: ExtractRequestParams<T>,
    responseCodec: t.Type<RC>
  ) => {
    try {
      const result = await client[operationId]({
        ...(requestParams as any),
        bearerAuth: session?.user?.accessToken
      });

      if (E.isLeft(result)) {
        setUseFetchError("validationError", readableReport(result.left));
      } else {
        // Get client http response
        const response = result.right;

        // Check 401 Unauthorized
        if (response.status === 401) {
          push("/auth/logout");
          return;
        }

        /** Set a response class type based on http response status code */
        const httpResponseClassType = manageHttpResponseStatusCode(
          response.status
        );

        switch (httpResponseClassType) {
          case "successful":
            // 2XX successful response status code
            pipe(
              responseCodec.decode(response.value),
              E.fold(
                e => setUseFetchError("validationError", readableReport(e)),
                setData
              )
            );
            break;
          case "clientError":
          case "serverError":
            setUseFetchError(
              "httpError",
              httpResponseClassType,
              response.status
            );
            break;
          // todo: manage other response class type
        }
      }
    } catch (err) {
      setUseFetchError("exceptionError", (err as Error).message);
    } finally {
      setLoading(false);
    }
  };

  return { data, error, loading, fetchData };
};

export default useFetch;
