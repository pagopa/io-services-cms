/* eslint-disable @typescript-eslint/no-explicit-any */
import { buildSnackbarItem } from "@/components/notification";
import { getConfiguration } from "@/config";
import { Client, createClient } from "@/generated/api/client";
import { readableReport } from "@pagopa/ts-commons/lib/reporters";
import * as E from "fp-ts/lib/Either";
import { pipe } from "fp-ts/lib/function";
import * as t from "io-ts";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import { useTranslation } from "next-i18next";
import { useSnackbar } from "notistack";
import { useEffect, useState } from "react";

/** Custom error type for `useFetch` */
export interface UseFetchError {
  /** readable error type classification */
  kind: UseFetchErrorStatusType;
  /** additional error info */
  message: string;
  /** http response status code, defined in case of _"httpError"_ `kind` */
  status?: number;
}

/** Custom `useFetch` error classification */
export type UseFetchErrorStatusType =
  | "exceptionError"
  | "httpError"
  | "validationError";

/** useFetch options */
export interface UseFetchOptions {
  /** FetchData notifications: \
   * `all` shows all fetchData results, `errors` shows only fetchData error results */
  notify: UseFetchOptionsResultType;
  /** Redirection at fetchData completition */
  redirect?: {
    /** Navigate to the provided href. Pushes a new history entry. */
    href: string;
    /** `all` redirect to `href` all fetchData results,\
     * `errors` redirect to `href` only fetchData error results */
    on: UseFetchOptionsResultType;
  };
}
export type UseFetchOptionsResultType = "all" | "errors";

/**
 * The status codes defined by RFC 9110
 *
 * For more details visit https://httpwg.org/specs/rfc9110.html#overview.of.status.codes
 */
type HttpResponseClassType =
  | "clientError"
  | "informational"
  | "redirection"
  | "serverError"
  | "successful"
  | "unknown";

/**
 * Given an http response status code, returns a response class as defined by **RFC 9110**
 * @param status
 * @returns
 */
const manageHttpResponseStatusCode = (
  status: number,
): HttpResponseClassType => {
  if (status >= 100 && status <= 199) {
    return "informational";
  } else if (status >= 200 && status <= 299) {
    return "successful";
  } else if (status >= 300 && status <= 399) {
    return "redirection";
  } else if (status >= 400 && status <= 499) {
    return "clientError";
  } else if (status >= 500 && status <= 599) {
    return "serverError";
  } else {
    return "unknown";
  }
};

/** IO Services CMS generated Api Client */
const generatedClient: Client = createClient({
  baseUrl: getConfiguration().API_BACKEND_BASE_URL,
  fetchApi: fetch as any as typeof fetch,
});

/** List of all client operations */
type ClientOperations = typeof generatedClient;

/** Extract operation request parameters inferred by client operationId */
type ExtractRequestParams<T extends keyof ClientOperations> = Parameters<
  ClientOperations[T]
>[0];

/**
 * Custom hook for client fetch API.
 *
 * This hook use `@pagopa/openapi-codegen-ts` autogenerated client, therefore makes available all and only APIs specified in the project root opeanapi.yaml
 * @param RC generics Response Codec
 * @returns `data` fetch result of _responseCodec_ type
 * @returns `error` in case of request error, decode failure or exceptions
 * @returns `loading` as boolean value for request pending state
 * @returns `fetchData` function to perform data fetching operation
 */
const useFetch = <RC>() => {
  const { t } = useTranslation();
  const [data, setData] = useState<RC>();
  const [error, setError] = useState<UseFetchError>();
  const [loading, setLoading] = useState(false);
  const [options, setOptions] = useState<UseFetchOptions>();

  const { push } = useRouter();
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { data: session } = useSession();

  // used to show notifications
  const { enqueueSnackbar } = useSnackbar();
  const [fetchTaskCounter, setFetchTaskCounter] = useState(0);

  /**
   * SetStateAction\<UseFetchError>
   * @param status
   * @param message
   * @returns
   */
  const setUseFetchError = (
    kind: UseFetchErrorStatusType,
    message: string,
    status?: number,
  ) =>
    setError({
      kind,
      message,
      status,
    });

  /**
   * IO Services CMS generated Api Client
   *
   * Client without defaults: we need to create it inside `useFetch()`
   * because a React Hook should not be called at the top level.
   * React Hooks must be called in a React function component or a custom React Hook function. */
  const client: Client = createClient({
    baseUrl: getConfiguration().API_BACKEND_BASE_URL,
    fetchApi: fetch as any as typeof fetch,
  });

  const buildNotificationMessage = () =>
    error?.status
      ? `${error.status} - ${t(error.status as unknown as string)}`
      : (error?.message ?? "");

  const buildNotification = () => {
    enqueueSnackbar(
      buildSnackbarItem({
        message: buildNotificationMessage(),
        severity: error === undefined ? "success" : "error",
        title:
          error === undefined
            ? t("notifications.success")
            : t(`notifications.${error?.kind as string}`),
      }),
    );
  };

  const manageOptions = () => {
    manageNotifications();
    if (options?.redirect) manageRedirections();
  };

  /** Shows a snackbar alert based on `notifications` param value */
  const manageNotifications = () => {
    switch (options?.notify) {
      case "all":
        buildNotification();
        break;
      case "errors":
        if (error !== undefined) buildNotification();
        break;
    }
  };

  /** Shows a snackbar alert based on `notifications` param value */
  const manageRedirections = () => {
    switch (options?.redirect?.on) {
      case "all":
        push(options.redirect.href);
        break;
      case "errors":
        if (error !== undefined) push(options.redirect.href);
        break;
    }
  };

  /**
   * Perform data fetching
   *
   * @param operationId openapi operationId
   * @param requestParams request parameters _(as specified in openapi)_
   * @param responseCodec io-ts expected response codec
   * @param options optional params
   * @returns */
  const fetchData = async <T extends keyof ClientOperations>(
    operationId: T,
    requestParams: ExtractRequestParams<T>,
    responseCodec: t.Type<RC>,
    options?: UseFetchOptions,
  ) => {
    setOptions(options);
    setData(undefined); // reset data
    setLoading(true); // set loading state
    try {
      const result = await client[operationId]({
        ...(requestParams as any),
        bearerAuth: "session?.user?.accessToken", //TODO: update OpenAPI and remove this header (next-auth will automatically set the JWT session as cookie header for each request)
      });

      if (E.isLeft(result)) {
        setUseFetchError("validationError", readableReport(result.left));
      } else {
        // Get client http response
        const response = result.right;

        // Check 401 Unauthorized
        if (response.status === 401) {
          push("/auth/logout");
          return;
        }

        /** Set a response class type based on http response status code */
        const httpResponseClassType = manageHttpResponseStatusCode(
          response.status,
        );

        switch (httpResponseClassType) {
          case "successful":
            // 2XX successful response status code
            pipe(
              responseCodec.decode(response.value),
              E.fold(
                (e) => setUseFetchError("validationError", readableReport(e)),
                setData,
              ),
            );
            break;
          case "clientError":
          case "serverError":
            setUseFetchError(
              "httpError",
              httpResponseClassType,
              response.status,
            );
            break;
          // todo: manage other response class type
        }
      }
    } catch (err) {
      setUseFetchError("exceptionError", (err as Error).message);
    } finally {
      setLoading(false); // reset loading state
      setFetchTaskCounter(() => fetchTaskCounter + 1);
    }
  };

  useEffect(() => {
    if (options) manageOptions();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fetchTaskCounter]);

  return { data, error, fetchData, loading };
};

export default useFetch;
