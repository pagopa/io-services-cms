/* eslint-disable max-lines-per-function */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { buildSnackbarItem } from "@/components/notification";
import { getConfiguration } from "@/config";
import { Client, createClient } from "@/generated/api/client";
import { readableReport } from "@pagopa/ts-commons/lib/reporters";
import * as E from "fp-ts/lib/Either";
import { pipe } from "fp-ts/lib/function";
import * as iots from "io-ts";
import { useRouter } from "next/navigation";
import { useTranslation } from "next-i18next";
import { useSnackbar } from "notistack";
import { useEffect, useState } from "react";

/** Custom error type for `useFetch` */
export interface UseFetchError {
  /** readable error type classification */
  kind: UseFetchErrorStatusType;
  /** additional error info */
  message: string;
  /** http response status code, defined in case of _"httpError"_ `kind` */
  status?: number;
}

/** Custom `useFetch` error classification */
export type UseFetchErrorStatusType =
  | "exceptionError"
  | "httpError"
  | "validationError";

/** useFetch options */
export interface UseFetchOptions {
  /** FetchData notifications: \
   * `all` shows all fetchData results, `errors` shows only fetchData error results */
  notify: UseFetchOptionsResultType;
  /** Redirection at fetchData completition */
  redirect?: {
    /** Navigate to the provided href. Pushes a new history entry. */
    href: string;
    /** `all` redirect to `href` all fetchData results,\
     * `errors` redirect to `href` only fetchData error results */
    on: UseFetchOptionsResultType;
  };
  /** Track fetch function execution reference ID _(useful for track operations on structured data as `arrays`, `recordsets`, etc.)_  */
  referenceId?: string;
}
export type UseFetchOptionsResultType = "all" | "errors";

/**
 * The status codes defined by RFC 9110
 *
 * For more details visit https://httpwg.org/specs/rfc9110.html#overview.of.status.codes
 */
type HttpResponseClassType =
  | "clientError"
  | "informational"
  | "redirection"
  | "serverError"
  | "successful"
  | "unknown";

/**
 * Given an http response status code, returns a response class as defined by **RFC 9110**
 * @param status
 * @returns
 */
const manageHttpResponseStatusCode = (
  status: number,
): HttpResponseClassType => {
  if (status >= 100 && status <= 199) {
    return "informational";
  } else if (status >= 200 && status <= 299) {
    return "successful";
  } else if (status >= 300 && status <= 399) {
    return "redirection";
  } else if (status >= 400 && status <= 499) {
    return "clientError";
  } else if (status >= 500 && status <= 599) {
    return "serverError";
  } else {
    return "unknown";
  }
};

/**
 * IO Services CMS generated Api Client
 *
 * Client without defaults: we need to create it inside `useFetch()`
 * because a React Hook should not be called at the top level.
 * React Hooks must be called in a React function component or a custom React Hook function. */
export const client: Client = createClient({
  baseUrl: getConfiguration().API_BACKEND_BASE_URL,
  fetchApi: fetch as any as typeof fetch,
});

/** List of all client operations */
type ClientOperations = typeof client;

/** Extract operation request parameters inferred by client operationId */
type ExtractRequestParams<T extends keyof ClientOperations> = Parameters<
  ClientOperations[T]
>[0];

/** Interface for referenceId */
const DataReference = iots.partial({ _referenceId: iots.string });
export type DataReference = iots.TypeOf<typeof DataReference>;

/**
 * Custom hook for client fetch API.
 *
 * This hook use `@pagopa/openapi-codegen-ts` autogenerated client, therefore makes available all and only APIs specified in the project root opeanapi.yaml
 * @param RC generics Response Codec
 * @returns `data` fetch result of _responseCodec_ type
 * @returns `error` in case of request error, decode failure or exceptions
 * @returns `loading` as boolean value for request pending state
 * @returns `fetchData` function to perform data fetching operation
 */
const useFetch = <RC>() => {
  const { t } = useTranslation();
  const [data, setData] = useState<DataReference & RC>();
  const [error, setError] = useState<UseFetchError>();
  const [loading, setLoading] = useState(false);
  const [options, setOptions] = useState<UseFetchOptions>();

  const { push } = useRouter();
  const { enqueueSnackbar } = useSnackbar();
  const [fetchTaskCounter, setFetchTaskCounter] = useState(0);

  /**
   * SetStateAction\<UseFetchError>
   * @param status
   * @param message
   * @returns
   */
  const setUseFetchError = (
    kind: UseFetchErrorStatusType,
    message: string,
    status?: number,
  ) =>
    setError({
      kind,
      message,
      status,
    });

  const buildNotificationMessage = () =>
    error?.status
      ? `${error.status} - ${t(error.status as unknown as string)}`
      : (error?.message ?? "");

  const buildNotification = () => {
    enqueueSnackbar(
      buildSnackbarItem({
        message: buildNotificationMessage(),
        severity: error === undefined ? "success" : "error",
        title:
          error === undefined
            ? t("notifications.success")
            : t(`notifications.${error?.kind as string}`),
      }),
    );
  };

  const manageOptions = () => {
    manageNotifications();
    if (options?.redirect) manageRedirections();
  };

  /** Shows a snackbar alert based on `notifications` param value */
  const manageNotifications = () => {
    switch (options?.notify) {
      case "all":
        buildNotification();
        break;
      case "errors":
        if (error !== undefined) buildNotification();
        break;
    }
  };

  /** Shows a snackbar alert based on `notifications` param value */
  const manageRedirections = () => {
    switch (options?.redirect?.on) {
      case "all":
        push(options.redirect.href);
        break;
      case "errors":
        if (error !== undefined) push(options.redirect.href);
        break;
    }
  };

  /**
   * Perform data fetching
   *
   * @param operationId openapi operationId
   * @param requestParams request parameters _(as specified in openapi)_
   * @param responseCodec io-ts expected response codec
   * @param options optional params
   * @returns */
  const fetchData = async <T extends keyof ClientOperations>(
    operationId: T,
    requestParams: ExtractRequestParams<T>,
    responseCodec: iots.Type<RC>,
    options?: UseFetchOptions,
  ): Promise<{
    data?: DataReference & RC;
    error?: UseFetchError;
    success: boolean;
  }> => {
    setOptions(options);
    setData(undefined); // reset data
    setLoading(true); // set loading state
    let fetchData: (DataReference & RC) | undefined;
    let fetchError: UseFetchError | undefined;
    try {
      const enhancedCodec = iots.intersection([responseCodec, DataReference]);

      const result = await client[operationId]({
        ...(requestParams as any),
      });

      if (E.isLeft(result)) {
        fetchError = {
          kind: "validationError" as UseFetchErrorStatusType,
          message: readableReport(result.left),
        };
        setUseFetchError(fetchError.kind, fetchError.message);
        return { error: fetchError, success: false };
      } else {
        // Get client http response
        const response = result.right;

        // Check 401 Unauthorized
        if (response.status === 401) {
          push("/auth/logout");
          return {
            error: {
              kind: "httpError",
              message: "401 Unauthorized",
              status: 401,
            },
            success: false,
          };
        }

        /** Set a response class type based on http response status code */
        const httpResponseClassType = manageHttpResponseStatusCode(
          response.status,
        );

        switch (httpResponseClassType) {
          case "successful":
            // 2XX successful response status code
            pipe(
              enhancedCodec.decode({
                ...response.value,
                _referenceId: options?.referenceId,
              }),
              E.fold(
                (e) => {
                  fetchError = {
                    kind: "validationError",
                    message: readableReport(e),
                  };
                  setUseFetchError(fetchError.kind, fetchError.message);
                },
                (decoded) => {
                  fetchData = decoded;
                  setData(decoded);
                },
              ),
            );
            if (fetchError) return { error: fetchError, success: false };
            return { data: fetchData, success: true };
          case "clientError":
          case "serverError":
            fetchError = {
              kind: "httpError" as UseFetchErrorStatusType,
              message: httpResponseClassType,
              status: response.status,
            };
            setUseFetchError(
              fetchError.kind,
              fetchError.message,
              fetchError.status,
            );
            return { error: fetchError, success: false };
          default:
            return {
              error: {
                kind: "httpError" as UseFetchErrorStatusType,
                message: httpResponseClassType,
                status: response.status,
              },
              success: false,
            };
        }
      }
    } catch (err) {
      fetchError = {
        kind: "exceptionError" as UseFetchErrorStatusType,
        message: (err as Error).message,
      };
      setUseFetchError(fetchError.kind, fetchError.message);
      return { error: fetchError, success: false };
    } finally {
      setLoading(false); // reset loading state
      setFetchTaskCounter(() => fetchTaskCounter + 1);
    }
  };

  useEffect(() => {
    if (options) manageOptions();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fetchTaskCounter]);

  return { data, error, fetchData, loading };
};

export default useFetch;
