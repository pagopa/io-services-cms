import { faker } from "@faker-js/faker";
import * as E from "fp-ts/lib/Either";
import { afterEach, describe, expect, it, Mock, vi } from "vitest";
import { getApimRestClient, upsertSubscription } from "../apim-service";

const mocks: {
  aServiceId: string;
  anUserId: string;
  aGroup: { id: string; name: string };
  upsertSubscription: Mock;
} = vi.hoisted(() => ({
  aServiceId: "aServiceId",
  anUserId: "anUserId",
  aGroup: { id: "aGroupId", name: "aGroupName" },
  upsertSubscription: vi.fn(),
}));

const { create, isAxiosError } = vi.hoisted(() => ({
  create: vi.fn().mockReturnValue({
    get: vi.fn(),
  }),
  isAxiosError: vi.fn().mockReturnValue(false),
}));

const { getAzureAccessToken } = vi.hoisted(() => ({
  getAzureAccessToken: vi.fn().mockReturnValue(Promise.resolve("aToken")),
}));

vi.mock("axios", async () => {
  const actual = await vi.importActual("axios");
  return {
    ...(actual as any),
    default: { create, isAxiosError },
  };
});

vi.mock("@/lib/be/azure-access-token", () => ({
  getAzureAccessToken,
}));

vi.hoisted(() => {
  const originalEnv = process.env;
  process.env = {
    ...originalEnv,
    AZURE_CLIENT_SECRET_CREDENTIAL_CLIENT_ID:
      "AZURE_CLIENT_SECRET_CREDENTIAL_CLIENT_ID",
    AZURE_CLIENT_SECRET_CREDENTIAL_SECRET:
      "AZURE_CLIENT_SECRET_CREDENTIAL_SECRET",
    AZURE_CLIENT_SECRET_CREDENTIAL_TENANT_ID:
      "AZURE_CLIENT_SECRET_CREDENTIAL_TENANT_ID",
    AZURE_APIM_PRODUCT_NAME: "AZURE_APIM_PRODUCT_NAME",
    AZURE_SUBSCRIPTION_ID: "AZURE_SUBSCRIPTION_ID",
    AZURE_APIM_RESOURCE_GROUP: "AZURE_APIM_RESOURCE_GROUP",
    AZURE_APIM: "AZURE_APIM",
    AZURE_APIM_SUBSCRIPTIONS_API_BASE_URL:
      "AZURE_APIM_SUBSCRIPTIONS_API_BASE_URL",
    API_APIM_MOCKING: "false",
  };
});

const ApimUtils = vi.hoisted(() => {
  const apimClientMock = { foo: "foo" };
  return {
    getApimClient: vi.fn((clientSecretCreds, subscriptionId) => {
      expect(clientSecretCreds).containSubset({
        AZURE_CLIENT_SECRET_CREDENTIAL_CLIENT_ID:
          "AZURE_CLIENT_SECRET_CREDENTIAL_CLIENT_ID",
        AZURE_CLIENT_SECRET_CREDENTIAL_SECRET:
          "AZURE_CLIENT_SECRET_CREDENTIAL_SECRET",
        AZURE_CLIENT_SECRET_CREDENTIAL_TENANT_ID:
          "AZURE_CLIENT_SECRET_CREDENTIAL_TENANT_ID",
      });
      expect(subscriptionId).toEqual("AZURE_SUBSCRIPTION_ID");
      return apimClientMock;
    }),
    getApimService: vi.fn((apimClient, resourceGroup, apim, productName) => {
      expect(apimClient).toStrictEqual(apimClientMock);
      expect(resourceGroup).toEqual("AZURE_APIM_RESOURCE_GROUP");
      expect(apim).toEqual("AZURE_APIM");
      expect(productName).toEqual("AZURE_APIM_PRODUCT_NAME");
      return {
        upsertSubscription: mocks.upsertSubscription,
      };
    }),
    SUBSCRIPTION_MANAGE_PREFIX: "MANAGE-",
    SUBSCRIPTION_MANAGE_GROUP_PREFIX: "MANAGE-GROUP-",
  };
});

vi.mock("@io-services-cms/external-clients", () => ({
  ApimUtils,
}));

afterEach(() => {
  vi.clearAllMocks();
});

describe("Apim Rest Client", () => {
  describe("getUserSubscriptions", () => {
    const expectedApiVersion = "2022-08-01";

    it("should return the list when response is OK", async () => {
      // given
      const get = vi.fn(() =>
        Promise.resolve({ status: 200, data: { name: mocks.aServiceId } }),
      );

      create.mockReturnValueOnce({
        get,
      });
      const limit = 10;
      const offset = 10;
      const filter = "filter";

      // when
      const apimRestClient = await getApimRestClient();
      const result = await apimRestClient.getUserSubscriptions(
        mocks.anUserId,
        filter,
        limit,
        offset,
      )();

      // then
      expect(get).toHaveBeenCalledOnce();
      expect(get).toHaveBeenCalledWith(
        `${process.env.AZURE_SUBSCRIPTION_ID}/resourceGroups/${process.env.AZURE_APIM_RESOURCE_GROUP}/providers/Microsoft.ApiManagement/service/${process.env.AZURE_APIM}/users/${mocks.anUserId}/subscriptions`,
        {
          params: {
            $filter: filter,
            $skip: offset,
            $top: limit,
            "api-version": expectedApiVersion,
          },
        },
      );
      expect(E.isRight(result)).toBeTruthy();
      if (E.isRight(result)) {
        expect(result.right).toStrictEqual({ name: mocks.aServiceId });
      }
    });

    it("should retry when apim response is 401 or 403 and return the list", async () => {
      // given
      const anExpiredAzureAccessToken = faker.internet.password(); // This is a fake expired token, it's not a real token, it's just a random string generated by fa
      const aNotExpiredAzureAccessToken = faker.internet.password(); // This is a fake not expired token, it's not a real token, it's just a random string generated by fa

      const get = vi
        .fn()
        .mockReturnValueOnce(Promise.reject({ response: { status: 403 } }))
        .mockReturnValueOnce(
          Promise.resolve({ status: 200, data: { name: mocks.aServiceId } }),
        );

      create.mockReturnValue({
        get,
      });

      isAxiosError.mockReturnValueOnce(true);

      getAzureAccessToken
        .mockReturnValueOnce(Promise.resolve(anExpiredAzureAccessToken))
        .mockReturnValueOnce(Promise.resolve(aNotExpiredAzureAccessToken));

      const limit = 10;
      const offset = 10;
      const filter = "filter";

      // when
      const apimRestClient = await getApimRestClient();
      const result = await apimRestClient.getUserSubscriptions(
        mocks.anUserId,
        filter,
        limit,
        offset,
      )();

      // then
      // Create should be called 2 times:
      // - the first one with the expired token
      // - the second one whit the not expired token
      expect(create).toHaveBeenCalledTimes(2);
      expect(create).toHaveBeenCalledWith(
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: `Bearer ${anExpiredAzureAccessToken}`,
          }),
        }),
      );
      expect(create).toHaveBeenCalledWith(
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: `Bearer ${aNotExpiredAzureAccessToken}`,
          }),
        }),
      );

      // get should be called 2 times
      expect(get).toHaveBeenCalledTimes(2);
      expect(get).toHaveBeenCalledWith(
        `${process.env.AZURE_SUBSCRIPTION_ID}/resourceGroups/${process.env.AZURE_APIM_RESOURCE_GROUP}/providers/Microsoft.ApiManagement/service/${process.env.AZURE_APIM}/users/${mocks.anUserId}/subscriptions`,
        {
          params: {
            $filter: filter,
            $skip: offset,
            $top: limit,
            "api-version": expectedApiVersion,
          },
        },
      );
      expect(isAxiosError).toHaveBeenCalledOnce();

      expect(E.isRight(result)).toBeTruthy();
      if (E.isRight(result)) {
        expect(result.right).toStrictEqual({ name: mocks.aServiceId });
      }
    });

    it("should not retry more the once when apim response is 401 or 403", async () => {
      // given
      const get = vi
        .fn()
        .mockReturnValueOnce(Promise.reject({ response: { status: 403 } }))
        .mockReturnValueOnce(Promise.reject({ response: { status: 403 } }))
        .mockReturnValueOnce(
          Promise.resolve({ status: 200, data: { name: mocks.aServiceId } }),
        );

      create.mockReturnValue({
        get,
      });

      isAxiosError.mockReturnValue(true);

      const limit = 10;
      const offset = 10;
      const filter = "filter";

      // when
      const apimRestClient = await getApimRestClient();
      const result = await apimRestClient.getUserSubscriptions(
        mocks.anUserId,
        filter,
        limit,
        offset,
      )();

      // then
      // Create should be called 2 times
      expect(create).toHaveBeenCalledTimes(2);

      // get should be called 2 times
      expect(get).toHaveBeenCalledTimes(2);
      expect(get).toHaveBeenCalledWith(
        `${process.env.AZURE_SUBSCRIPTION_ID}/resourceGroups/${process.env.AZURE_APIM_RESOURCE_GROUP}/providers/Microsoft.ApiManagement/service/${process.env.AZURE_APIM}/users/${mocks.anUserId}/subscriptions`,
        {
          params: {
            $filter: filter,
            $skip: offset,
            $top: limit,
            "api-version": expectedApiVersion,
          },
        },
      );
      expect(isAxiosError).toHaveBeenCalledTimes(2);

      expect(E.isLeft(result)).toBeTruthy();
    });

    it("should not retry when apim response is not 401 or 403 and return the error", async () => {
      // given
      const get = vi
        .fn()
        .mockReturnValueOnce(Promise.reject({ response: { status: 500 } }));

      create.mockReturnValue({
        get,
      });

      isAxiosError.mockReturnValue(true);

      const limit = 10;
      const offset = 10;
      const filter = "filter";

      // when
      const apimRestClient = await getApimRestClient();
      const result = await apimRestClient.getUserSubscriptions(
        mocks.anUserId,
        filter,
        limit,
        offset,
      )();

      // then
      expect(create).toHaveBeenCalledTimes(1);
      expect(get).toHaveBeenCalledTimes(1);
      expect(get).toHaveBeenCalledWith(
        `${process.env.AZURE_SUBSCRIPTION_ID}/resourceGroups/${process.env.AZURE_APIM_RESOURCE_GROUP}/providers/Microsoft.ApiManagement/service/${process.env.AZURE_APIM}/users/${mocks.anUserId}/subscriptions`,
        {
          params: {
            $filter: filter,
            $skip: offset,
            $top: limit,
            "api-version": expectedApiVersion,
          },
        },
      );
      expect(isAxiosError).toHaveBeenCalledTimes(1);

      expect(E.isLeft(result)).toBeTruthy();
    });
  });
});

describe("upsertSubscription", () => {
  it("should throw Error when provided a bad type", () => {
    // when and then
    expect(() => upsertSubscription("bad type" as any, "ownerId")).toThrowError(
      "Invalid type",
    );
  });

  it.each`
    type              | ownerId           | value           | expectedSubId                        | expectedSubName
    ${"MANAGE"}       | ${mocks.anUserId} | ${undefined}    | ${"MANAGE-" + mocks.anUserId}        | ${undefined}
    ${"MANAGE_GROUP"} | ${mocks.anUserId} | ${mocks.aGroup} | ${"MANAGE-GROUP-" + mocks.aGroup.id} | ${mocks.aGroup.name}
  `(
    "should call upsertSubscription with proper subscriptionId when type is $type",
    ({ type, ownerId, value, expectedSubId, expectedSubName }) => {
      // given
      const upsertSubscriptionResultMock = { bar: "bar" };
      mocks.upsertSubscription.mockReturnValueOnce(
        upsertSubscriptionResultMock,
      );

      // when
      const res = upsertSubscription(type, ownerId, value);

      // then
      expect(res).toStrictEqual(upsertSubscriptionResultMock);
      expect(mocks.upsertSubscription).toHaveBeenCalledOnce();
      const params = value
        ? [ownerId, expectedSubId, expectedSubName]
        : [ownerId, expectedSubId];
      expect(mocks.upsertSubscription).toHaveBeenCalledWith(...params);
    },
  );
});
