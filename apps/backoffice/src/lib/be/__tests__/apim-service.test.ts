import { faker } from "@faker-js/faker";
import * as E from "fp-ts/lib/Either";
import { afterEach, describe, expect, it, Mock, vi } from "vitest";
import { getApimRestClient, upsertSubscription } from "../apim-service";

const mocks: {
  aServiceId: string;
  anUserId: string;
  aGroupId: string;
  upsertSubscription: Mock;
} = vi.hoisted(() => ({
  aServiceId: "aServiceId",
  anUserId: "anUserId",
  aGroupId: "aGroupId",
  upsertSubscription: vi.fn(),
}));

const { create, isAxiosError } = vi.hoisted(() => ({
  create: vi.fn().mockReturnValue({
    get: vi.fn(),
  }),
  isAxiosError: vi.fn().mockReturnValue(false),
}));

const { getAzureAccessToken } = vi.hoisted(() => ({
  getAzureAccessToken: vi.fn().mockReturnValue(Promise.resolve("aToken")),
}));

vi.mock("axios", async () => {
  const actual = await vi.importActual("axios");
  return {
    ...(actual as any),
    default: { create, isAxiosError },
  };
});

vi.mock("@/lib/be/azure-access-token", () => ({
  getAzureAccessToken,
}));

const { cacheMock } = vi.hoisted(() => ({
  cacheMock: (func) => func,
}));
vi.mock("react", () => ({
  cache: cacheMock,
}));

vi.hoisted(() => {
  const originalEnv = process.env;
  process.env = {
    ...originalEnv,
    AZURE_CLIENT_SECRET_CREDENTIAL_CLIENT_ID:
      "AZURE_CLIENT_SECRET_CREDENTIAL_CLIENT_ID",
    AZURE_CLIENT_SECRET_CREDENTIAL_SECRET:
      "AZURE_CLIENT_SECRET_CREDENTIAL_SECRET",
    AZURE_CLIENT_SECRET_CREDENTIAL_TENANT_ID:
      "AZURE_CLIENT_SECRET_CREDENTIAL_TENANT_ID",
    AZURE_APIM_PRODUCT_NAME: "AZURE_APIM_PRODUCT_NAME",
    AZURE_SUBSCRIPTION_ID: "AZURE_SUBSCRIPTION_ID",
    AZURE_APIM_RESOURCE_GROUP: "AZURE_APIM_RESOURCE_GROUP",
    AZURE_APIM: "AZURE_APIM",
    AZURE_APIM_SUBSCRIPTIONS_API_BASE_URL:
      "AZURE_APIM_SUBSCRIPTIONS_API_BASE_URL",
    API_APIM_MOCKING: "false",
  };
});

const ApimUtils = vi.hoisted(() => {
  const apimClientMock = { foo: "foo" };
  return {
    getApimClient: vi.fn((clientSecretCreds, subscriptionId) => {
      expect(clientSecretCreds).containSubset({
        AZURE_CLIENT_SECRET_CREDENTIAL_CLIENT_ID:
          "AZURE_CLIENT_SECRET_CREDENTIAL_CLIENT_ID",
        AZURE_CLIENT_SECRET_CREDENTIAL_SECRET:
          "AZURE_CLIENT_SECRET_CREDENTIAL_SECRET",
        AZURE_CLIENT_SECRET_CREDENTIAL_TENANT_ID:
          "AZURE_CLIENT_SECRET_CREDENTIAL_TENANT_ID",
      });
      expect(subscriptionId).toEqual("AZURE_SUBSCRIPTION_ID");
      return apimClientMock;
    }),
    getApimService: vi.fn((apimClient, resourceGroup, apim, productName) => {
      expect(apimClient).toStrictEqual(apimClientMock);
      expect(resourceGroup).toEqual("AZURE_APIM_RESOURCE_GROUP");
      expect(apim).toEqual("AZURE_APIM");
      expect(productName).toEqual("AZURE_APIM_PRODUCT_NAME");
      return {
        upsertSubscription: mocks.upsertSubscription,
      };
    }),
    SUBSCRIPTION_MANAGE_PREFIX: "MANAGE-",
    SUBSCRIPTION_MANAGE_GROUP_PREFIX: "MANAGE-GROUP-",
  };
});

vi.mock("@io-services-cms/external-clients", () => ({
  ApimUtils,
}));

afterEach(() => {
  vi.clearAllMocks();
});

describe("Apim Rest Client", () => {
  describe("getServiceList", () => {
    it("should return the list when response is OK", async () => {
      const get = vi.fn(() =>
        Promise.resolve({ status: 200, data: { name: mocks.aServiceId } }),
      );

      create.mockReturnValueOnce({
        get,
      });

      const apimRestClient = await getApimRestClient();
      const result = await apimRestClient.getServiceList(
        mocks.anUserId,
        10,
        10,
      )();

      expect(get).toHaveBeenCalledOnce();
      expect(E.isRight(result)).toBeTruthy();
      if (E.isRight(result)) {
        expect(result.right).toStrictEqual({ name: mocks.aServiceId });
      }
    });

    it("should retry when apim response is 401 or 403 and return the list", async () => {
      const anExpiredAzureAccessToken = faker.internet.password(); // This is a fake expired token, it's not a real token, it's just a random string generated by fa
      const aNotExpiredAzureAccessToken = faker.internet.password(); // This is a fake not expired token, it's not a real token, it's just a random string generated by fa

      const get = vi
        .fn()
        .mockReturnValueOnce(Promise.reject({ response: { status: 403 } }))
        .mockReturnValueOnce(
          Promise.resolve({ status: 200, data: { name: mocks.aServiceId } }),
        );

      create.mockReturnValue({
        get,
      });

      isAxiosError.mockReturnValueOnce(true);

      getAzureAccessToken
        .mockReturnValueOnce(Promise.resolve(anExpiredAzureAccessToken))
        .mockReturnValueOnce(Promise.resolve(aNotExpiredAzureAccessToken));

      const apimRestClient = await getApimRestClient();
      const result = await apimRestClient.getServiceList(
        mocks.anUserId,
        10,
        10,
      )();

      // Create should be called 2 times:
      // - the first one with the expired token
      // - the second one whit the not expired token
      expect(create).toHaveBeenCalledTimes(2);
      expect(create).toHaveBeenCalledWith(
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: `Bearer ${anExpiredAzureAccessToken}`,
          }),
        }),
      );
      expect(create).toHaveBeenCalledWith(
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: `Bearer ${aNotExpiredAzureAccessToken}`,
          }),
        }),
      );

      // get should be called 2 times
      expect(get).toHaveBeenCalledTimes(2);
      expect(isAxiosError).toHaveBeenCalledOnce();

      expect(E.isRight(result)).toBeTruthy();
      if (E.isRight(result)) {
        expect(result.right).toStrictEqual({ name: mocks.aServiceId });
      }
    });

    it("should not retry more the once when apim response is 401 or 403", async () => {
      const get = vi
        .fn()
        .mockReturnValueOnce(Promise.reject({ response: { status: 403 } }))
        .mockReturnValueOnce(Promise.reject({ response: { status: 403 } }))
        .mockReturnValueOnce(
          Promise.resolve({ status: 200, data: { name: mocks.aServiceId } }),
        );

      create.mockReturnValue({
        get,
      });

      isAxiosError.mockReturnValue(true);

      const apimRestClient = await getApimRestClient();
      const result = await apimRestClient.getServiceList(
        mocks.anUserId,
        10,
        10,
      )();

      // Create should be called 2 times
      expect(create).toHaveBeenCalledTimes(2);

      // get should be called 2 times
      expect(get).toHaveBeenCalledTimes(2);
      expect(isAxiosError).toHaveBeenCalledTimes(2);

      expect(E.isLeft(result)).toBeTruthy();
    });

    it("should not retry when apim response is not 401 or 403 and return the error", async () => {
      const get = vi
        .fn()
        .mockReturnValueOnce(Promise.reject({ response: { status: 500 } }));

      create.mockReturnValue({
        get,
      });

      isAxiosError.mockReturnValue(true);

      const apimRestClient = await getApimRestClient();
      const result = await apimRestClient.getServiceList(
        mocks.anUserId,
        10,
        10,
      )();

      expect(create).toHaveBeenCalledTimes(1);
      expect(get).toHaveBeenCalledTimes(1);
      expect(isAxiosError).toHaveBeenCalledTimes(1);

      expect(E.isLeft(result)).toBeTruthy();
    });
  });
});

describe("upsertSubscription", () => {
  it("should throw Error when provided a bad type", () => {
    expect(() => upsertSubscription("bad type" as any, "ownerId")).toThrowError(
      "Invalid type",
    );
  });

  it.each`
    type              | ownerId           | value             | expectedSubId
    ${"MANAGE"}       | ${mocks.anUserId} | ${undefined}      | ${"MANAGE-" + mocks.anUserId}
    ${"MANAGE_GROUP"} | ${mocks.anUserId} | ${mocks.aGroupId} | ${"MANAGE-GROUP-" + mocks.aGroupId}
  `(
    "should call upsertSubscription with proper subscriptionId when type is $type",
    ({ type, ownerId, value, expectedSubId }) => {
      const upsertSubscriptionResultMock = { bar: "bar" };
      mocks.upsertSubscription.mockReturnValueOnce(
        upsertSubscriptionResultMock,
      );

      const res = upsertSubscription(type, ownerId, value);

      expect(res).toStrictEqual(upsertSubscriptionResultMock);

      expect(mocks.upsertSubscription).toHaveBeenCalledOnce();
      expect(mocks.upsertSubscription).toHaveBeenCalledWith(
        ownerId,
        expectedSubId,
      );
    },
  );
});
