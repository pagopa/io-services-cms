// DO NOT EDIT THIS FILE
// This file has been generated by gen-api-models
// eslint-disable sonar/max-union-size
// eslint-disable sonarjs/no-identical-functions

import * as t from "io-ts";

import * as r from "@pagopa/ts-commons/lib/requests";

import { Problem } from "./Problem";

import { Institution } from "./Institution";

import { PageOfUserGroupResource } from "./PageOfUserGroupResource";

import { ProductResource } from "./ProductResource";

import { AckPayloadRequest } from "./AckPayloadRequest";

import { SearchUserDto } from "./SearchUserDto";

import { UserInfoResource } from "./UserInfoResource";

import { InstitutionsResponse } from "./InstitutionsResponse";

import { OnboardingsResponse } from "./OnboardingsResponse";

import { UserResponse } from "./UserResponse";

import { SupportRequestDto } from "./SupportRequestDto";

import { SupportResponse } from "./SupportResponse";

import { TokenListResponse } from "./TokenListResponse";

/****************************************************************
 * getInstitutionsUsingGET
 */

// Request type definition
export type GetInstitutionsUsingGETT = r.IGetApiRequestType<
  { readonly apiKeyHeader: string; readonly userIdForAuth: string },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getInstitutionsUsingGETDefaultResponses = {
  200: t.undefined,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetInstitutionsUsingGETResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getInstitutionsUsingGETDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionsUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionsUsingGETDefaultResponses as unknown) as GetInstitutionsUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getInstitutionsUsingGETDefaultDecoder = () =>
  getInstitutionsUsingGETDecoder();

/****************************************************************
 * getInstitutionProductUsersUsingGET
 */

// Request type definition
export type GetInstitutionProductUsersUsingGETT = r.IGetApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly institutionId: string;
    readonly userIdForAuth: string;
    readonly userId?: string;
    readonly productRoles?: array;
  },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getInstitutionProductUsersUsingGETDefaultResponses = {
  200: t.undefined,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetInstitutionProductUsersUsingGETResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getInstitutionProductUsersUsingGETDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionProductUsersUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionProductUsersUsingGETDefaultResponses as unknown) as GetInstitutionProductUsersUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getInstitutionProductUsersUsingGETDefaultDecoder = () =>
  getInstitutionProductUsersUsingGETDecoder();

/****************************************************************
 * getInstitutionUserProductsUsingGET
 */

// Request type definition
export type GetInstitutionUserProductsUsingGETT = r.IGetApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly institutionId: string;
    readonly userId: string;
  },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getInstitutionUserProductsUsingGETDefaultResponses = {
  200: t.undefined,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetInstitutionUserProductsUsingGETResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getInstitutionUserProductsUsingGETDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionUserProductsUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionUserProductsUsingGETDefaultResponses as unknown) as GetInstitutionUserProductsUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getInstitutionUserProductsUsingGETDefaultDecoder = () =>
  getInstitutionUserProductsUsingGETDecoder();

/****************************************************************
 * getInstitution
 */

// Request type definition
export type GetInstitutionT = r.IGetApiRequestType<
  { readonly apiKeyHeader: string; readonly id: string },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, Institution, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<404, Problem, never>
>;

export const getInstitutionDefaultResponses = {
  200: Institution,
  400: Problem,
  404: Problem
};

export type GetInstitutionResponsesT<
  A0 = Institution,
  C0 = Institution,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  404: t.Type<A2, C2>;
};

export function getInstitutionDecoder<
  A0 = Institution,
  C0 = Institution,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
>(
  overrideTypes:
    | Partial<GetInstitutionResponsesT<A0, C0, A1, C1, A2, C2>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<404, A2, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionDefaultResponses as unknown) as GetInstitutionResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A2, never>>;

  return r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d404);
}

// Decodes the success response with the type defined in the specs
export const getInstitutionDefaultDecoder = () => getInstitutionDecoder();

/****************************************************************
 * getUserGroupsUsingGET
 */

// Request type definition
export type GetUserGroupsUsingGETT = r.IGetApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly institutionId?: string;
    readonly page?: number;
    readonly size?: number;
    readonly sort?: array;
    readonly userId?: string;
    readonly status?: string;
  },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, PageOfUserGroupResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getUserGroupsUsingGETDefaultResponses = {
  200: PageOfUserGroupResource,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetUserGroupsUsingGETResponsesT<
  A0 = PageOfUserGroupResource,
  C0 = PageOfUserGroupResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getUserGroupsUsingGETDecoder<
  A0 = PageOfUserGroupResource,
  C0 = PageOfUserGroupResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetUserGroupsUsingGETResponsesT<A0, C0, A1, C1, A2, C2, A3, C3, A4, C4>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getUserGroupsUsingGETDefaultResponses as unknown) as GetUserGroupsUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getUserGroupsUsingGETDefaultDecoder = () =>
  getUserGroupsUsingGETDecoder();

/****************************************************************
 * getProductUsingGET
 */

// Request type definition
export type GetProductUsingGETT = r.IGetApiRequestType<
  { readonly apiKeyHeader: string; readonly institutionType?: string },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, ProductResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getProductUsingGETDefaultResponses = {
  200: ProductResource,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetProductUsingGETResponsesT<
  A0 = ProductResource,
  C0 = ProductResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getProductUsingGETDecoder<
  A0 = ProductResource,
  C0 = ProductResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetProductUsingGETResponsesT<A0, C0, A1, C1, A2, C2, A3, C3, A4, C4>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getProductUsingGETDefaultResponses as unknown) as GetProductUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getProductUsingGETDefaultDecoder = () =>
  getProductUsingGETDecoder();

/****************************************************************
 * getInstitutionsByGeoTaxonomiesUsingGET
 */

// Request type definition
export type GetInstitutionsByGeoTaxonomiesUsingGETT = r.IGetApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly geoTaxonomies: string;
    readonly userIdForAuth: string;
    readonly searchMode?: string;
  },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getInstitutionsByGeoTaxonomiesUsingGETDefaultResponses = {
  200: t.undefined,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetInstitutionsByGeoTaxonomiesUsingGETResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getInstitutionsByGeoTaxonomiesUsingGETDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionsByGeoTaxonomiesUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionsByGeoTaxonomiesUsingGETDefaultResponses as unknown) as GetInstitutionsByGeoTaxonomiesUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getInstitutionsByGeoTaxonomiesUsingGETDefaultDecoder = () =>
  getInstitutionsByGeoTaxonomiesUsingGETDecoder();

/****************************************************************
 * getInstitutionGeographicTaxonomiesUsingGET
 */

// Request type definition
export type GetInstitutionGeographicTaxonomiesUsingGETT = r.IGetApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly institutionId: string;
    readonly userIdForAuth: string;
  },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getInstitutionGeographicTaxonomiesUsingGETDefaultResponses = {
  200: t.undefined,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetInstitutionGeographicTaxonomiesUsingGETResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getInstitutionGeographicTaxonomiesUsingGETDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionGeographicTaxonomiesUsingGETResponsesT<
          A0,
          C0,
          A1,
          C1,
          A2,
          C2,
          A3,
          C3,
          A4,
          C4
        >
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionGeographicTaxonomiesUsingGETDefaultResponses as unknown) as GetInstitutionGeographicTaxonomiesUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getInstitutionGeographicTaxonomiesUsingGETDefaultDecoder = () =>
  getInstitutionGeographicTaxonomiesUsingGETDecoder();

/****************************************************************
 * getContractUsingGET
 */

// Request type definition
export type GetContractUsingGETT = r.IGetApiRequestType<
  { readonly apiKeyHeader: string; readonly institutionId: string },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<404, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getContractUsingGETDefaultResponses = {
  200: t.undefined,
  400: Problem,
  401: Problem,
  404: Problem,
  500: Problem
};

export type GetContractUsingGETResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function getContractUsingGETDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem,
  A4 = Problem,
  C4 = Problem
>(
  overrideTypes:
    | Partial<
        GetContractUsingGETResponsesT<A0, C0, A1, C1, A2, C2, A3, C3, A4, C4>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getContractUsingGETDefaultResponses as unknown) as GetContractUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getContractUsingGETDefaultDecoder = () =>
  getContractUsingGETDecoder();

/****************************************************************
 * getDelegationsUsingGET
 */

// Request type definition
export type GetDelegationsUsingGETT = r.IGetApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly institutionId?: string;
    readonly brokerId?: string;
    readonly productId?: string;
    readonly mode?: string;
  },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<404, Problem, never>
>;

export const getDelegationsUsingGETDefaultResponses = {
  200: t.undefined,
  400: Problem,
  404: Problem
};

export type GetDelegationsUsingGETResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  404: t.Type<A2, C2>;
};

export function getDelegationsUsingGETDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
>(
  overrideTypes:
    | Partial<GetDelegationsUsingGETResponsesT<A0, C0, A1, C1, A2, C2>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<404, A2, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getDelegationsUsingGETDefaultResponses as unknown) as GetDelegationsUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A2, never>>;

  return r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d404);
}

// Decodes the success response with the type defined in the specs
export const getDelegationsUsingGETDefaultDecoder = () =>
  getDelegationsUsingGETDecoder();

/****************************************************************
 * messageAcknowledgmentUsingPOST
 */

// Request type definition
export type MessageAcknowledgmentUsingPOSTT = r.IPostApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly messageId: string;
    readonly status: string;
    readonly body?: AckPayloadRequest | ReadableStream<Uint8Array> | Buffer;
  },
  "Content-Type" | "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, undefined, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const messageAcknowledgmentUsingPOSTDefaultResponses = {
  200: t.undefined,
  400: Problem,
  401: Problem,
  500: Problem
};

export type MessageAcknowledgmentUsingPOSTResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function messageAcknowledgmentUsingPOSTDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        MessageAcknowledgmentUsingPOSTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((messageAcknowledgmentUsingPOSTDefaultResponses as unknown) as MessageAcknowledgmentUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const messageAcknowledgmentUsingPOSTDefaultDecoder = () =>
  messageAcknowledgmentUsingPOSTDecoder();

/****************************************************************
 * getUserInfoUsingPOST
 */

// Request type definition
export type GetUserInfoUsingPOSTT = r.IPostApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly body?: SearchUserDto | ReadableStream<Uint8Array> | Buffer;
  },
  "Content-Type" | "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, UserInfoResource, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const getUserInfoUsingPOSTDefaultResponses = {
  200: UserInfoResource,
  400: Problem,
  401: Problem,
  500: Problem
};

export type GetUserInfoUsingPOSTResponsesT<
  A0 = UserInfoResource,
  C0 = UserInfoResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function getUserInfoUsingPOSTDecoder<
  A0 = UserInfoResource,
  C0 = UserInfoResource,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<GetUserInfoUsingPOSTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getUserInfoUsingPOSTDefaultResponses as unknown) as GetUserInfoUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getUserInfoUsingPOSTDefaultDecoder = () =>
  getUserInfoUsingPOSTDecoder();

/****************************************************************
 * getInstitutionsByTaxCodeUsingGET
 */

// Request type definition
export type GetInstitutionsByTaxCodeUsingGETT = r.IGetApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly taxCode?: string;
    readonly subunitCode?: string;
    readonly origin?: string;
    readonly originId?: string;
  },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, InstitutionsResponse, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<404, Problem, never>
>;

export const getInstitutionsByTaxCodeUsingGETDefaultResponses = {
  200: InstitutionsResponse,
  400: Problem,
  404: Problem
};

export type GetInstitutionsByTaxCodeUsingGETResponsesT<
  A0 = InstitutionsResponse,
  C0 = InstitutionsResponse,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  404: t.Type<A2, C2>;
};

export function getInstitutionsByTaxCodeUsingGETDecoder<
  A0 = InstitutionsResponse,
  C0 = InstitutionsResponse,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
>(
  overrideTypes:
    | Partial<
        GetInstitutionsByTaxCodeUsingGETResponsesT<A0, C0, A1, C1, A2, C2>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<404, A2, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getInstitutionsByTaxCodeUsingGETDefaultResponses as unknown) as GetInstitutionsByTaxCodeUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A2, never>>;

  return r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d404);
}

// Decodes the success response with the type defined in the specs
export const getInstitutionsByTaxCodeUsingGETDefaultDecoder = () =>
  getInstitutionsByTaxCodeUsingGETDecoder();

/****************************************************************
 * getOnboardingsInstitutionUsingGET
 */

// Request type definition
export type GetOnboardingsInstitutionUsingGETT = r.IGetApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly institutionId: string;
    readonly productId?: string;
  },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, OnboardingsResponse, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<404, Problem, never>
>;

export const getOnboardingsInstitutionUsingGETDefaultResponses = {
  200: OnboardingsResponse,
  400: Problem,
  404: Problem
};

export type GetOnboardingsInstitutionUsingGETResponsesT<
  A0 = OnboardingsResponse,
  C0 = OnboardingsResponse,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  404: t.Type<A2, C2>;
};

export function getOnboardingsInstitutionUsingGETDecoder<
  A0 = OnboardingsResponse,
  C0 = OnboardingsResponse,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
>(
  overrideTypes:
    | Partial<
        GetOnboardingsInstitutionUsingGETResponsesT<A0, C0, A1, C1, A2, C2>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<404, A2, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getOnboardingsInstitutionUsingGETDefaultResponses as unknown) as GetOnboardingsInstitutionUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A2, never>>;

  return r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d404);
}

// Decodes the success response with the type defined in the specs
export const getOnboardingsInstitutionUsingGETDefaultDecoder = () =>
  getOnboardingsInstitutionUsingGETDecoder();

/****************************************************************
 * getUserInfoUsingGET
 */

// Request type definition
export type GetUserInfoUsingGETT = r.IGetApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly id: string;
    readonly institutionId?: string;
  },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, UserResponse, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<404, Problem, never>
>;

export const getUserInfoUsingGETDefaultResponses = {
  200: UserResponse,
  400: Problem,
  404: Problem
};

export type GetUserInfoUsingGETResponsesT<
  A0 = UserResponse,
  C0 = UserResponse,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  404: t.Type<A2, C2>;
};

export function getUserInfoUsingGETDecoder<
  A0 = UserResponse,
  C0 = UserResponse,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
>(
  overrideTypes:
    | Partial<GetUserInfoUsingGETResponsesT<A0, C0, A1, C1, A2, C2>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<404, A2, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getUserInfoUsingGETDefaultResponses as unknown) as GetUserInfoUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A2, never>>;

  return r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d404);
}

// Decodes the success response with the type defined in the specs
export const getUserInfoUsingGETDefaultDecoder = () =>
  getUserInfoUsingGETDecoder();

/****************************************************************
 * sendSupportRequestUsingPOST
 */

// Request type definition
export type SendSupportRequestUsingPOSTT = r.IPostApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly body?: SupportRequestDto | ReadableStream<Uint8Array> | Buffer;
  },
  "Content-Type" | "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, SupportResponse, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<401, Problem, never>
  | r.IResponseType<500, Problem, never>
>;

export const sendSupportRequestUsingPOSTDefaultResponses = {
  200: SupportResponse,
  400: Problem,
  401: Problem,
  500: Problem
};

export type SendSupportRequestUsingPOSTResponsesT<
  A0 = SupportResponse,
  C0 = SupportResponse,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function sendSupportRequestUsingPOSTDecoder<
  A0 = SupportResponse,
  C0 = SupportResponse,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem,
  A3 = Problem,
  C3 = Problem
>(
  overrideTypes:
    | Partial<
        SendSupportRequestUsingPOSTResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((sendSupportRequestUsingPOSTDefaultResponses as unknown) as SendSupportRequestUsingPOSTResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const sendSupportRequestUsingPOSTDefaultDecoder = () =>
  sendSupportRequestUsingPOSTDecoder();

/****************************************************************
 * getTokensFromProductUsingGET
 */

// Request type definition
export type GetTokensFromProductUsingGETT = r.IGetApiRequestType<
  {
    readonly apiKeyHeader: string;
    readonly productId: string;
    readonly page?: number;
    readonly size?: number;
  },
  "Ocp-Apim-Subscription-Key",
  never,
  | r.IResponseType<200, TokenListResponse, never>
  | r.IResponseType<400, Problem, never>
  | r.IResponseType<404, Problem, never>
>;

export const getTokensFromProductUsingGETDefaultResponses = {
  200: TokenListResponse,
  400: Problem,
  404: Problem
};

export type GetTokensFromProductUsingGETResponsesT<
  A0 = TokenListResponse,
  C0 = TokenListResponse,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  404: t.Type<A2, C2>;
};

export function getTokensFromProductUsingGETDecoder<
  A0 = TokenListResponse,
  C0 = TokenListResponse,
  A1 = Problem,
  C1 = Problem,
  A2 = Problem,
  C2 = Problem
>(
  overrideTypes:
    | Partial<GetTokensFromProductUsingGETResponsesT<A0, C0, A1, C1, A2, C2>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<404, A2, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getTokensFromProductUsingGETDefaultResponses as unknown) as GetTokensFromProductUsingGETResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A2, never>>;

  return r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d404);
}

// Decodes the success response with the type defined in the specs
export const getTokensFromProductUsingGETDefaultDecoder = () =>
  getTokensFromProductUsingGETDecoder();
